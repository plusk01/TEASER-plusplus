/**
 * Copyright 2020, Massachusetts Institute of Technology,
 * Cambridge, MA 02139
 * All Rights Reserved
 * Authors: Jingnan Shi, et al. (see THANKS for the full author list)
 * See LICENSE for the license information
 */

#include <algorithm>
#include <map>
#include <iostream>
#include <chrono>

#include "mex.h"
#include <Eigen/Core>

#include "teaser_mex_utils.h"
#include "teaser/registration.h"

enum class INPUT_PARAMS : int {
  src = 0,
  dst = 1,
  cbar2 = 2,
  noise_bound = 3,
  estimate_scaling = 4,
  rotation_estimation_algorithm = 5,
  rotation_gnc_factor = 6,
  rotation_max_iterations = 7,
  rotation_cost_threshold = 8,
  inlier_selection_algorithm = 9,
  kcore_heuristic_threshold = 10,
  max_clique_threads = 11,
};

enum class OUTPUT_PARAMS : int {
  s_est = 0,
  R_est = 1,
  t_est = 2,
  times = 3,
  inlier_graph = 4,
  maxclique = 5,
  rotation_inliers = 6,
  translation_inliers = 7,
  pmc_times = 8,
  pmc_omegas = 9,
  pmc_exact = 10,
  pmc_input_info = 11,
};

typedef bool (*mexTypeCheckFunction)(const mxArray*);
const std::map<INPUT_PARAMS, mexTypeCheckFunction> INPUT_PARMS_MAP{
    {INPUT_PARAMS::src, &isPointCloudMatrix},
    {INPUT_PARAMS::dst, &isPointCloudMatrix},
    {INPUT_PARAMS::cbar2, &isRealDoubleScalar},
    {INPUT_PARAMS::noise_bound, &isRealDoubleScalar},
    {INPUT_PARAMS::estimate_scaling, &mxIsLogicalScalar},
    {INPUT_PARAMS::rotation_estimation_algorithm, &isRealDoubleScalar},
    {INPUT_PARAMS::rotation_gnc_factor, &isRealDoubleScalar},
    {INPUT_PARAMS::rotation_max_iterations, &isRealDoubleScalar},
    {INPUT_PARAMS::rotation_cost_threshold, &isRealDoubleScalar},
    {INPUT_PARAMS::inlier_selection_algorithm, &isRealDoubleScalar},
    {INPUT_PARAMS::kcore_heuristic_threshold, &isRealDoubleScalar},
    {INPUT_PARAMS::max_clique_threads, &isRealDoubleScalar},
};
const std::map<OUTPUT_PARAMS, mexTypeCheckFunction> OUTPUT_PARMS_MAP{
    {OUTPUT_PARAMS::s_est, &isRealDoubleScalar},
    {OUTPUT_PARAMS::R_est, &isRealDoubleMatrix<3, 3>},
    {OUTPUT_PARAMS::t_est, &isRealDoubleMatrix<3, 1>},
    {OUTPUT_PARAMS::times, nullptr},
    {OUTPUT_PARAMS::inlier_graph, nullptr},
    {OUTPUT_PARAMS::maxclique, nullptr},
    {OUTPUT_PARAMS::rotation_inliers, nullptr},
    {OUTPUT_PARAMS::translation_inliers, nullptr},
    {OUTPUT_PARAMS::pmc_times, nullptr},
    {OUTPUT_PARAMS::pmc_omegas, nullptr},
    {OUTPUT_PARAMS::pmc_exact, nullptr},
    {OUTPUT_PARAMS::pmc_input_info, nullptr},
};

/**
 * This is the MATLAB binding for TEASER++.
 *
 * Input:
 * - src: a 3-by-N matrix of 3D points representing points to be transformed
 * - dst: a 3-by-N matrix of 3D points representing points after transformation
 * - cbar2: square of maximum allowed ratio between noise and noise bound (see [1]).
 * - noise_bound: a floating-point number indicating the bound on noise
 * - estimate_scaling: a boolean indicating whether scale needs to be estimated
 * - rotation_max_iterations: maximum iterations for the rotation estimation loop
 * - rotation_cost_threshold: cost threshold for rotation termination
 * - rotation_gnc_factor: gnc factor for rotation estimation
 *                        for GNC-TLS method: it's multiplied on the GNC control parameter
 *                        for FGR method: it's divided on the GNC control parameter
 * - rotation_estimation_algorithm: a number indicating the rotation estimation method used;
 *                                  if it's 0: GNC-TLS
 *                                  if it's 1: FGR
 * - inlier_selection_algorithm: a number indicating the  method used;
 *                                  0: PMC_EXACT
 *                                  1: PMC_HEU
 *                                  2: KCORE_HEU
 *                                  3: NONE
 * - kcore_heuristic_threshold: threshold for k-core heuristic. If the inlier graph has a max core
 *                              number greater than kcore_heuristic_threshold * number of vertices,
 *                              then the nodes with core number == max core number are directly
 *                              returned. If not, then the algorithm will proceed to use PMC to find
 *                              an exact clique.
 * - max_clique_threads: Sets the number of threads to use for PMC (affects all of openmp)
 *
 * Output:
 * - s_est estimated scale (scalar)
 * - R_est estimated rotation matrix (3-by-3 matrix)
 * - t_est estimated translation vector (3-by-1 matrix)
 * - times is list of 5 timing stats on the underlying TEASER++ library computing a solution.
 * - inlier_graph is the graph generated by supposed inlier TIMs used for MCIS.
 * - maxclique is the vector of indices of the largest set of consistent inliers found by MCIS.
 * - rotation_inliers is the vector of indices of inliers after R estimation.
 * - translation_inliers is the vector of indices of inliers after t estimation.
 * - pmc_times is a vector of [ heu, exact ] times taken for each PMC step.
 * - pmc_omegas is a vector of [ heu, exact ] clique sizes returned by each PMC step.
 * - pmc_exact is a flag that indicates if PMC exact ran / was needed after Heu step.
 * - pmc_input_info is a vector of [ |V|, |E|, density ] stats about input graph.
 *
 * [1] H. Yang, J. Shi, and L. Carlone, “TEASER: Fast and Certifiable Point Cloud Registration,”
 * arXiv:2001.07715 [cs, math], Jan. 2020.
 *
 */
void mexFunction(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]) {

  // Check for proper number of arguments
  if (nrhs != INPUT_PARMS_MAP.size()) {
    mexErrMsgIdAndTxt("teaserSolve:nargin", "Wrong number of input arguments.");
  }
  if (nlhs != OUTPUT_PARMS_MAP.size()) {
    mexErrMsgIdAndTxt("teaserSolve:nargin", "Wrong number of output arguments.");
  }

  // Check for proper input types
  for (const auto& pair : INPUT_PARMS_MAP) {
    if (!pair.second(prhs[toUType(pair.first)])) {
      std::stringstream error_msg;
      error_msg << "Argument " << toUType(pair.first) + 1 << " has the wrong type.\n";
      mexErrMsgIdAndTxt("teaserSolve:nargin", error_msg.str().c_str());
    }
  }

  TEASER_DEBUG_MEX_MSG("Arguments type checks passed.\n");
  mexEvalString("drawnow;");

  // Prepare parameters
  // Prepare source and destination Eigen point matrices
  Eigen::Matrix<double, 3, Eigen::Dynamic> src_eigen, dst_eigen;
  mexPointMatrixToEigenMatrix(prhs[toUType(INPUT_PARAMS::src)], &src_eigen);
  mexPointMatrixToEigenMatrix(prhs[toUType(INPUT_PARAMS::dst)], &dst_eigen);

  // Other parameters
  auto cbar2 = static_cast<double>(*mxGetPr(prhs[toUType(INPUT_PARAMS::cbar2)]));
  auto noise_bound = static_cast<double>(*mxGetPr(prhs[toUType(INPUT_PARAMS::noise_bound)]));
  auto estimate_scaling =
      static_cast<bool>(*mxGetPr(prhs[toUType(INPUT_PARAMS::estimate_scaling)]));
  auto rotation_estimation_method =
      static_cast<int>(*mxGetPr(prhs[toUType(INPUT_PARAMS::rotation_estimation_algorithm)]));
  auto rotation_gnc_factor =
      static_cast<double>(*mxGetPr(prhs[toUType(INPUT_PARAMS::rotation_gnc_factor)]));
  auto rotation_max_iterations =
      static_cast<size_t>(*mxGetPr(prhs[toUType(INPUT_PARAMS::rotation_max_iterations)]));
  auto rotation_cost_threshold =
      static_cast<double>(*mxGetPr(prhs[toUType(INPUT_PARAMS::rotation_cost_threshold)]));
  auto inlier_selection_algorithm =
      static_cast<int>(*mxGetPr(prhs[toUType(INPUT_PARAMS::inlier_selection_algorithm)]));
  auto kcore_heuristic_threshold =
      static_cast<double>(*mxGetPr(prhs[toUType(INPUT_PARAMS::kcore_heuristic_threshold)]));
  auto max_clique_threads =
      static_cast<double>(*mxGetPr(prhs[toUType(INPUT_PARAMS::max_clique_threads)]));

  // Prepare the TEASER++ solver for solving registration problem
  teaser::RobustRegistrationSolver::Params params;
  params.noise_bound = noise_bound;
  params.cbar2 = cbar2;
  params.estimate_scaling = estimate_scaling;
  params.rotation_max_iterations = rotation_max_iterations;
  params.rotation_gnc_factor = rotation_gnc_factor;
  params.rotation_cost_threshold = rotation_cost_threshold;
  params.kcore_heuristic_threshold = kcore_heuristic_threshold;
  params.max_clique_threads = max_clique_threads;

  switch (rotation_estimation_method) {
  case 0: { // GNC-TLS method
    TEASER_DEBUG_MEX_MSG("Use GNC-TLS for rotation estimation.\n");
    params.rotation_estimation_algorithm =
        teaser::RobustRegistrationSolver::ROTATION_ESTIMATION_ALGORITHM::GNC_TLS;
    break;
  }
  case 1: { // FGR method
    TEASER_DEBUG_MEX_MSG("Use FGR for rotation estimation.\n");
    params.rotation_estimation_algorithm =
        teaser::RobustRegistrationSolver::ROTATION_ESTIMATION_ALGORITHM::FGR;
    break;
  }
  default: {
    TEASER_DEBUG_MEX_MSG("Rotation estimation method given does not exist. Use GNC-TLS instead.\n");
    params.rotation_estimation_algorithm =
        teaser::RobustRegistrationSolver::ROTATION_ESTIMATION_ALGORITHM::GNC_TLS;
    break;
  }
  }

  switch (inlier_selection_algorithm) {
  case 0: { // PMC_EXACT method
    TEASER_DEBUG_MEX_MSG("Use PMC_EXACT for inlier selection.\n");
    params.inlier_selection_mode =
        teaser::RobustRegistrationSolver::INLIER_SELECTION_MODE::PMC_EXACT;
    break;
  }
  case 1: { // PMC_HEU method
    TEASER_DEBUG_MEX_MSG("Use PMC_HEU for inlier selection.\n");
    params.inlier_selection_mode = teaser::RobustRegistrationSolver::INLIER_SELECTION_MODE::PMC_HEU;
    break;
  }
  case 2: { // KCORE_HEU method
    TEASER_DEBUG_MEX_MSG("Use KCORE_HEU for inlier selection.\n");
    params.inlier_selection_mode =
        teaser::RobustRegistrationSolver::INLIER_SELECTION_MODE::KCORE_HEU;
    break;
  }
  case 3: { // NONE
    TEASER_DEBUG_MEX_MSG("No inlier selection step after scale pruning.\n");
    params.inlier_selection_mode = teaser::RobustRegistrationSolver::INLIER_SELECTION_MODE::NONE;
    break;
  }
  default: {
    TEASER_DEBUG_MEX_MSG("Unknown inlier selection algorithm given. Use PMC_EXACT instead.\n");
    params.inlier_selection_mode =
        teaser::RobustRegistrationSolver::INLIER_SELECTION_MODE::PMC_EXACT;
    break;
  }
  }

  teaser::RobustRegistrationSolver solver(params);

  TEASER_DEBUG_MEX_MSG("Start TEASER++ solver.\n");
  mexEvalString("drawnow;");

  // Start the timer
  const auto start = std::chrono::high_resolution_clock::now();

  // Solve
  assert(src_eigen.size() != 0);
  assert(dst_eigen.size() != 0);
  solver.solve(src_eigen, dst_eigen);

  // Stop the timer
  const auto stop = std::chrono::high_resolution_clock::now();
  const double t_e2e = static_cast<double>(std::chrono::duration_cast<std::chrono::microseconds>(stop - start).count()) / 1e6;

  auto solution = solver.getSolution();

  TEASER_DEBUG_MEX_MSG("TEASER++ has found a solution in %f milliseconds.\n", t_e2e*1e3);
  mexEvalString("drawnow;");

  // Populate outputs
  plhs[toUType(OUTPUT_PARAMS::s_est)] = mxCreateDoubleScalar(solution.scale);
  // Populate output R matrix
  plhs[toUType(OUTPUT_PARAMS::R_est)] = mxCreateDoubleMatrix(3, 3, mxREAL);
  Eigen::Map<Eigen::Matrix3d> R_map(mxGetPr(plhs[toUType(OUTPUT_PARAMS::R_est)]), 3, 3);
  R_map = solution.rotation;

  // Populate output T vector
  plhs[toUType(OUTPUT_PARAMS::t_est)] = mxCreateDoubleMatrix(3, 1, mxREAL);
  Eigen::Map<Eigen::Matrix<double, 3, 1>> t_map(mxGetPr(plhs[toUType(OUTPUT_PARAMS::t_est)]), 3, 1);
  t_map = solution.translation;

  // Populate time output vector
  std::vector<double> timevec = { t_e2e, solution.t_scale, solution.t_mcis, solution.t_rotation, solution.t_translation };
  plhs[toUType(OUTPUT_PARAMS::times)] = mxCreateDoubleMatrix(1, timevec.size(), mxREAL);
  memcpy(mxGetData(plhs[toUType(OUTPUT_PARAMS::times)]), &timevec[0], timevec.size()*sizeof(double));

  // Return inlier graph adjacency matrix
  std::vector<std::vector<int>> adjlist = solver.getInlierGraph();
  const int num_v = adjlist.size();
  Eigen::MatrixXd adj_matrix(num_v, num_v);
  for (size_t i=0; i<num_v; ++i) {
    const std::vector<int>& c_edges = adjlist[i];
    for (size_t j=0; j<num_v; ++j) {
      if (std::find(c_edges.begin(), c_edges.end(), j) != c_edges.end()) {
        adj_matrix(i, j) = 1;
      } else {
        adj_matrix(i, j) = 0;
      }
    }
  }
  plhs[toUType(OUTPUT_PARAMS::inlier_graph)] = mxCreateDoubleMatrix(num_v, num_v, mxREAL);
  Eigen::Map<Eigen::MatrixXd>(mxGetPr(plhs[toUType(OUTPUT_PARAMS::inlier_graph)]), adj_matrix.rows(), adj_matrix.cols()) = adj_matrix;

  std::vector<int> maxclique = solver.getInlierMaxClique();
  std::vector<double> mcidx; mcidx.reserve(maxclique.size());
  std::transform(maxclique.begin(), maxclique.end(), std::back_inserter(mcidx),
          [](int x){ return x+1; }); // for matlab 1-based indexing
  plhs[toUType(OUTPUT_PARAMS::maxclique)] = mxCreateDoubleMatrix(1, mcidx.size(), mxREAL);
  memcpy(mxGetData(plhs[toUType(OUTPUT_PARAMS::maxclique)]), &mcidx[0], mcidx.size()*sizeof(double));

  // Populate inliers according to rotation estimation stage
  // These inliers map via 'dst_tims_map_rotation_'. n.b., that for CHAIN, this index map can
  // maps directly to the original indices, but for FULL the indices will map to indices of
  // the max clique from mcis, which then map to the original indices (as with tinliers).
  std::vector<int> rinliers = solver.getRotationInliers();
  std::vector<double> ridx; ridx.reserve(rinliers.size());
  std::transform(rinliers.begin(), rinliers.end(), std::back_inserter(ridx),
          [](int x){ return x+1; }); // for matlab 1-based indexing
  plhs[toUType(OUTPUT_PARAMS::rotation_inliers)] = mxCreateDoubleMatrix(1, ridx.size(), mxREAL);
  memcpy(mxGetData(plhs[toUType(OUTPUT_PARAMS::rotation_inliers)]), &ridx[0], ridx.size()*sizeof(double));

  // Populate inliers according to translation estimation stage
  // These inliers indices are indices of the reduced max clique, which then map to original indices
  std::vector<int> tinliers = solver.getTranslationInliers();
  std::vector<double> tidx; tidx.reserve(tinliers.size());
  std::transform(tinliers.begin(), tinliers.end(), std::back_inserter(tidx),
          [](int x){ return x+1; }); // for matlab 1-based indexing
  plhs[toUType(OUTPUT_PARAMS::translation_inliers)] = mxCreateDoubleMatrix(1, tidx.size(), mxREAL);
  memcpy(mxGetData(plhs[toUType(OUTPUT_PARAMS::translation_inliers)]), &tidx[0], tidx.size()*sizeof(double));

  //
  // PMC solution info
  //

  // PMC times - [ Heu, Exact ]
  std::vector<double> pmctvec = { solution.pmcinfo.t_heu, solution.pmcinfo.t_exact };
  plhs[toUType(OUTPUT_PARAMS::pmc_times)] = mxCreateDoubleMatrix(1, pmctvec.size(), mxREAL);
  memcpy(mxGetData(plhs[toUType(OUTPUT_PARAMS::pmc_times)]), &pmctvec[0], pmctvec.size()*sizeof(double));

  // PMC omegas - [ Heu, Exact ]
  std::vector<double> pmcomegas = { static_cast<double>(solution.pmcinfo.omega_heu), static_cast<double>(solution.pmcinfo.omega_exact) };
  plhs[toUType(OUTPUT_PARAMS::pmc_omegas)] = mxCreateDoubleMatrix(1, pmcomegas.size(), mxREAL);
  memcpy(mxGetData(plhs[toUType(OUTPUT_PARAMS::pmc_omegas)]), &pmcomegas[0], pmcomegas.size()*sizeof(double));

  // PMC exact flag
  plhs[toUType(OUTPUT_PARAMS::pmc_exact)] = mxCreateDoubleScalar(((solution.pmcinfo.exact_ran)?1.0:0.0));

  // PMC info about input graph - [ |V|, |E|, density ]
  std::vector<double> pmcinputinfo = { static_cast<double>(solution.pmcinfo.num_vertices), static_cast<double>(solution.pmcinfo.num_edges), solution.pmcinfo.density };
  plhs[toUType(OUTPUT_PARAMS::pmc_input_info)] = mxCreateDoubleMatrix(1, pmcinputinfo.size(), mxREAL);
  memcpy(mxGetData(plhs[toUType(OUTPUT_PARAMS::pmc_input_info)]), &pmcinputinfo[0], pmcinputinfo.size()*sizeof(double));
}
